# 02-react-components.md

## Анализ React-компонентов

### Общие наблюдения

Проект активно использует React с TypeScript, Chakra UI для UI-компонентов и TanStack Router для навигации. Компоненты преимущественно следуют современным практикам, но есть ряд замечаний, касающихся размера, смешения ответственности, избыточных запросов и управления состоянием.

### 1. `Header.tsx`

*   **Файл:** `src/components/business/Header.tsx`
*   **Тип проблемы:** style
*   **Описание проблемы:** Компонент `Header` выполняет несколько задач: отображение логотипа и названия, навигация назад/вперед, открытие бокового меню (на мобильных устройствах), поиск и создание новой задачи.
*   **Почему это плохо (senior-аргументация):** Несмотря на небольшой размер, компонент содержит логику, связанную с различными аспектами UI: навигация, управление состоянием бокового меню (`useHeaderStore`), открытие модальных окон (`useModals`), адаптивность (`useMediaQuery`). Это нарушает принцип единой ответственности (SRP), хотя и в небольшой степени.
*   **К чему это приведёт со временем:** При дальнейшем добавлении функциональности в заголовок, он может стать слишком большим и сложным для поддержки.
*   **Какой принцип нарушен:** Single Responsibility Principle (SRP).

*   **Файл:** `src/components/business/Header.tsx`
*   **Тип проблемы:** react / hooks usage
*   **Описание проблемы:** Компонент активно использует различные хуки (`useMediaQuery`, `useCanGoBack`, `useCanGoForward`, `useRouter`, `useHeaderStore`, `useModals`).
*   **Почему это плохо (senior-аргументация):** Использование хуков для управления состоянием и логикой внутри компонента, который должен быть преимущественно презентационным, размывает границы. Хотя это и является распространенной практикой в React, для более крупных приложений может быть предпочтительнее вынести часть этой логики в кастомные хуки или менеджеры состояния, чтобы компонент оставался более декларативным.
*   **К чему это приведёт со временем:** Усложнение переиспользования компонента в других контекстах, где его зависимости (например, `useRouter`, `useHeaderStore`) могут быть неприменимы.
*   **Какой принцип нарушен:** Separation of Concerns.


### 2. `ActionBar.tsx`

*   **Файл:** `src/components/business/ActionBar.tsx`
*   **Тип проблемы:** react / architecture
*   **Описание проблемы:** Компонент `ActionBar` содержит логику для отображения выбранных элементов, открытия диалога подтверждения удаления и вызова мутации для удаления (`useMutation(deleteIssuesOptions())`). Он напрямую взаимодействует с глобальным состоянием выделения (`useSelectionStore`).
*   **Почему это плохо (senior-аргументация):** Компонент смешивает UI-представление (панель действий, диалог) с бизнес-логикой (удаление элементов, управление состоянием выделения). Хотя это и допустимо для компонентов среднего размера, он становится сильно связанным с конкретной логикой удаления и состоянием выделения. Это может затруднить его переиспользование в сценариях, где требуется другая логика действий или другое управление выделением.
*   **К чему это приведёт со временем:** Компонент будет сложно адаптировать под новые требования, если потребуется изменить логику удаления или механизм выделения.
*   **Какой принцип нарушен:** Single Responsibility Principle (SRP), High Cohesion.

### 3. `IssueItem.tsx`

*   **Файл:** `src/features/issues/components/IssueItem.tsx`
*   **Тип проблемы:** react / infra / architecture
*   **Описание проблемы:** Компонент `IssueItem` отвечает за отображение одной задачи (issue). Он выполняет избыточный запрос данных `useGetProjects()` для каждого элемента списка, управляет локальным состоянием выделения (`isSelected`), смешивает его с состоянием контекстного меню (`isMenuOpen`), получает данные для `StatusSelect` и `LabelSelect` (предположительно, эти компоненты сами не делают запросы, но `IssueItem` загружает проекты, что косвенно влияет на них), а также обрабатывает навигацию через `Link`.
*   **Почему это плохо (senior-аргументация):**
    *   **Избыточный запрос данных:** Вызов `useGetProjects()` внутри каждого `IssueItem` приводит к множеству одинаковых запросов, если в списке задач много элементов. Это неэффективно и может замедлить производительность приложения, особенно при большом количестве задач.
    *   **Смешение ответственности:** Компонент занимается отображением данных задачи, управлением выделением (через `useSelectionStore`), управлением контекстным меню (`isMenuOpen`, `pos`), получением данных о проектах (избыточно) и построением ссылки для навигации. Это слишком много ответственности для одного компонента, даже если он не является "god-component".
    *   **Неявные контракты:** Ожидается, что `issue?.module_id` и `issue?.project_id` будут доступны или их отсутствие будет корректно обрабатываться. Однако, `project_custom_id` вычисляется на основе `projects?.filter(...)`, что может вернуть `undefined` и привести к ошибкам, если `projects` еще не загружены или `issue?.project_id` отсутствует.
    *   **Отладочный код:** Наличие `console.log` в компоненте указывает на незавершенность или недостаточный контроль качества кода.
*   **К чему это приведёт со временем:**
    *   **Проблемы с производительностью:** Большое количество параллельных запросов к `useGetProjects()` замедлит загрузку списков.
    *   **Сложность поддержки:** Разделение ответственности в компоненте усложняет его модификацию или исправление багов.
    *   **Непредсказуемое поведение:** Некорректная обработка отсутствующих данных или временных состояний может привести к ошибкам.
*   **Какой принцип нарушен:** Separation of Concerns, High Cohesion, DRY (Don't Repeat Yourself), Performance Optimization.

### 4. Container / Presentational Separation

*   **`Header.tsx`:** Гибридный. Содержит некоторую логику, но в основном презентационный.
*   **`ActionBar.tsx`:** Гибридный. Содержит UI и часть бизнес-логики (удаление).
*   **`IssueItem.tsx`:** Гибридный. Смешивает отображение данных, управление состоянием выделения, получение дополнительных данных (проекты) и навигацию.

В целом, наблюдается тенденция к гибридным компонентам, которые совмещают презентационную часть с некоторой логикой и управлением состоянием. Для более крупных приложений рекомендуется более четкое разделение.

### 5. Anti-patterns (Prop Drilling, God-Components, Implicit Contracts)

*   **Prop Drilling:** Не замечено явного проп-дриллинга в рассмотренных компонентах. Управление состоянием через Zustand (`useSelectionStore`, `useHeaderStore`) и TanStack Query (`useGetProjects`) помогает избежать этого.
*   **God-Components:** Рассмотренные компоненты не являются "god-components" (огромными компонентами, которые делают всё). Однако `IssueItem.tsx` имеет тенденцию к этому из-за смешения ответственности.
*   **Implicit Contracts:** Как упомянуто для `IssueItem.tsx`, есть неявные контракты, связанные с доступностью данных (`issue?.project_id`, `issue?.module_id`) и их корректной обработкой. Также, `StatusSelect` и `LabelSelect` предполагают, что они получают корректные значения и имеют свою внутреннюю логику (возможно, тоже запросы).
