# 01-architecture-review.md

## Архитектурный аудит

### 1. Наличие слоев (UI / logic / domain / infrastructure)

Проект имеет явно выраженные слои для UI, API/Infrastructure, State Management и Hooks. Однако слой Domain не выделен явно.

*   **UI Layer:** Представлен директориями `src/components/`, `src/features/*/components`, `src/pages/`.
*   **Infrastructure Layer:** Очевиден в `src/api/supabase.ts` и `src/api/appwrite.tsx`, которые отвечают за взаимодействие с BaaS-провайдерами.
*   **API/Data Access Layer:** Реализован в `src/api/queries/`, где с использованием TanStack Query формируются запросы к данным.
*   **Logic Layer (Application/Presentation Logic):** Распределен между `src/hooks/` (переиспользуемая логика), `src/stores/` (управление клиентским состоянием) и `src/api/queries/` (логика формирования запросов и обработки данных).
*   **Domain Layer:** Отсутствует как выделенный слой. Бизнес-логика, не относящаяся напрямую к UI или инфраструктуре, смешана с другими слоями.

### 2. Направление зависимостей

Направление зависимостей в целом соответствует принципам слоеной архитектуры:
UI (pages, components, features) -> Logic (hooks, stores) -> API/Data Access (api/queries) -> Infrastructure (api/supabase, api/appwrite).
Тем не менее, есть нарушения, где детали низкоуровневых слоев просачиваются в более высокие или смешиваются с ними.

### 3. Смешение ответственности

#### Проблема 1: Прямое формирование запросов к базе данных в API Query файлах

*   **Файл:** `src/api/queries/issues.api.ts` (и аналогичные файлы в `src/api/queries/`)
*   **Тип проблемы:** architecture / infra
*   **Описание проблемы:** В функциях `queryFn` для TanStack Query (например, в `getIssuesOptions` и `useGetIssues`) происходит прямое формирование запросов к Supabase (`diogen.from("issues").select("*").eq(...)`, `.is(...)`, `.order(...)`). Это смешивает ответственность за высокоуровневую оркестрацию данных с низкоуровневой логикой построения запросов к конкретному провайдеру данных.
*   **Почему это плохо (senior-аргументация):** Нарушает принцип разделения ответственности (SRP) и принцип изоляции инфраструктуры. API-слой должен быть сосредоточен на *контракте* взаимодействия с данными (что нужно получить/отправить), а не на *деталях реализации* того, как эти данные извлекаются или сохраняются в конкретной БД. Прямое использование методов Supabase в `queryFn` означает, что логика, специфичная для Supabase, "просачивается" в слой, который должен быть более абстрактным. Это затрудняет тестирование, понимание и изменение.
*   **К чему это приведёт со временем:**
    *   **Сложность замены провайдера данных:** При необходимости замены Supabase на другой BaaS или кастомный бэкенд потребуется переписывать не только базовые клиенты, но и все `queryFn` в `src/api/queries`, что приведет к значительным изменениям по всей кодовой базе.
    *   **Усложнение тестирования:** Юнит-тестирование бизнес-логики, которая может быть встроена в эти `queryFn` (например, фильтрация `filterByEmptyModule`), становится затруднительным без мокирования всей цепочки Supabase-вызовов.
    *   **Повышенная связанность:** Модули, использующие эти API-файлы, косвенно становятся зависимыми от деталей реализации Supabase, даже если они напрямую не импортируют `supabase.ts`.
    *   **Дублирование логики:** Построение похожих запросов (фильтрация, сортировка) может приводить к дублированию кода в разных `queryFn`.
*   **Какой принцип нарушен:** Single Responsibility Principle (SRP), Separation of Concerns, Infrastructure Isolation.

#### Проблема 2: Смешение инициализации инфраструктуры с React-логикой и отладочным кодом

*   **Файл:** `src/api/appwrite.tsx`
*   **Тип проблемы:** architecture / infra / style
*   **Описание проблемы:** Файл `appwrite.tsx` содержит инициализацию клиента Appwrite и одновременно использует `useQuery` через `createAppwriteHooks`. Также присутствуют закомментированные фрагменты кода, связанные с аутентификацией и отладкой.
*   **Почему это плохо (senior-аргументация):** Смешение инициализации инфраструктурного клиента (Appwrite `Client`, `Account`, `TablesDB`) с высокоуровневыми хуками React (`useQuery` через `createAppwriteHooks`) и неактивной/отладочной логикой (закомментированные вызовы `account.createEmailPasswordSession`) нарушает принцип разделения ответственности. Файл, ответственный за инициализацию клиента, должен заниматься только этим. `useQuery` – это хук презентационного слоя, который не должен появляться на уровне инфраструктуры. Закомментированный код является "мертвым кодом", который должен быть удален.
*   **К чему это приведёт со временем:**
    *   **Затрудненное тестирование:** Тестирование Appwrite-клиента становится зависимым от окружения React.
    *   **Неясные границы слоев:** Размывается граница между инфраструктурой и презентационным слоем, что усложняет понимание потоков данных и контроля.
    *   **Технический долг:** Закомментированный код является техническим долгом, который может запутать будущих разработчиков.
    *   **Сложность при смене фреймворков:** Если в будущем потребуется использовать Appwrite-клиент вне React-контекста, это будет проблематично из-за жесткой привязки к `useQuery`.
*   **Какой принцип нарушен:** Single Responsibility Principle (SRP), Separation of Concerns, Layered Architecture, Clean Code.

#### Проблема 3: Наличие экспериментального/временного кода в `src/api/wow`

*   **Файл:** `src/api/wow` директория
*   **Тип проблемы:** architecture / style / maintainability
*   **Описание проблемы:** В директории `src/api/` присутствует поддиректория `wow/`, содержащая файлы с названиями `gemini-learn-this.md`, `gemini-tutorial.md`, `gemini-work.tsx`, `myturn.tsx`, `test.tsx`, `wow.tsx`. Эти файлы выглядят как временные, экспериментальные или учебные материалы.
*   **Почему это плохо (senior-аргументация):** В production-grade проекте, который будет развиваться годами, наличие таких "песочниц" или временных файлов в основной кодовой базе (особенно в критическом слое, таком как `api`) нарушает принцип чистоты кодовой базы и снижает ее предсказуемость. Это указывает на отсутствие строгих стандартов CI/CD, которые должны препятствовать попаданию подобного кода в master/main ветки. Это также затрудняет навигацию и понимание истинного назначения файлов в директории `api`.
*   **К чему это приведёт со временем:**
    *   **Увеличение технического долга:** Такие файлы редко удаляются и со временем накапливаются.
    *   **Снижение поддерживаемости:** Новым разработчикам будет сложнее понять, какие файлы являются частью проекта, а какие — нет.
    *   **Риск ошибок:** Случайные импорты или зависимости от этого "экспериментального" кода могут привести к ошибкам в продакшене.
    *   **Размывание ответственности:** Директория `api` теряет свою четкую ответственность, становясь свалкой для всего, что связано с API, включая прототипы.
*   **Какой принцип нарушен:** Clean Code, Single Responsibility Principle (директории), Maintainability.

### 4. Coupling между модулями

*   **Тесная связанность API Query файлов с BaaS SDK:** Файлы в `src/api/queries` напрямую используют методы SDK Supabase/Appwrite. Это создает сильную связанность с конкретной реализацией BaaS, что было подробно описано в "Проблема 1: Прямое формирование запросов к базе данных в API Query файлах".
*   **Coupling `src/api/appwrite.tsx` к `appwrite.config.json`:** `appwrite.tsx` напрямую импортирует `appwriteConfig` из `appwrite.config.json`. Это ожидаемо, но использование `tables.find` для получения ID таблиц из конфига может быть хрупким при изменениях в структуре `appwrite.config.json` или большом количестве таблиц.
*   **Предполагаемая тесная связанность между `features` и `api/queries`:** Модули фич, вероятно, напрямую импортируют и используют хуки из `api/queries`. Это типично для React-приложений, но важно следить за тем, чтобы бизнес-логика не дублировалась и не смешивалась между этими слоями, а также чтобы не происходило пробрасывание параметров, специфичных для API, через несколько слоев UI.

### 5. Feature-based vs technical structure

Проект использует гибридный подход. `src/features/` и `src/pages/` демонстрируют feature-based структуру, в то время как `src/components/`, `src/hooks/`, `src/stores/`, `src/api/` являются техническими слоями. Этот подход может быть эффективным, если границы между слоями и фичами четко определены и соблюдаются. Однако наличие `src/api/wow` нарушает чистоту технического слоя `api`, и это также может стать проблемой, если бизнес-логика начнет просачиваться в эти технические слои, делая их менее переиспользуемыми.
