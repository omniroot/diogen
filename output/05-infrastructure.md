# 05-infrastructure.md

## Анализ API / Infrastructure

### 1. Работа с API

*   **Многообразие BaaS-провайдеров:** Проект интегрирует два бэкенд-сервиса как платформу (BaaS): Supabase и Appwrite.
    *   **Supabase:** Используется через SDK `supabase-js` (`src/api/supabase.ts`) и интегрирован с TanStack Query в файлах `src/api/queries/*.api.ts`.
    *   **Appwrite:** Используется через SDK `appwrite` (`src/api/appwrite.tsx`) с кастомными хуками (`createAppwriteHooks`), которые, вероятно, также используют TanStack Query под капотом.
*   **Оркестрация запросов:** `@tanstack/react-query` активно используется для управления серверным состоянием, кеширования и запросами. Это является хорошей практикой для современных React-приложений.
*   **Прямая зависимость от SDK:** Ключевой проблемой является то, что файлы в `src/api/queries/*.api.ts` напрямую используют методы SDK Supabase (например, `diogen.from(...).select(...)`). Это означает, что бизнес-логика формирования запросов тесно связана с реализацией конкретного BaaS-провайдера.

### 2. Изоляция HTTP / Storage / Env

*   **HTTP-клиенты:** Клиенты Supabase и Appwrite инициализируются в соответствующих файлах (`supabase.ts`, `appwrite.tsx`) и получают конфигурацию (URL, ключи) из переменных окружения (`import.meta.env`), загружаемых из `.env` файлов. Это обеспечивает базовую изоляцию конфигурации.
*   **Storage:** Явный слой для абстракции работы с хранилищем (например, S3-совместимое хранилище) отсутствует. Предполагается, что функциональность хранения данных осуществляется через BaaS-провайдеров.
*   **Env:** Переменные окружения используются стандартным образом через Vite (`import.meta.env`).

### 3. Возможность замены API

*   **Вывод:** Замена BaaS-провайдеров или переход на кастомный бэкенд **затруднена**.
*   **Аргументация:** Прямая интеграция методов SDK Supabase (`diogen.from(...)`, `.select()`, `.eq()` и т.д.) в `queryFn` файлах `src/api/queries/` создает высокую связанность с реализацией Supabase. При необходимости смены провайдера данных, придется переписывать не только базовые клиенты, но и значительную часть логики формирования запросов по всему приложению.
*   **Последствия:** Увеличивает стоимость внесения изменений в инфраструктурный слой, снижает гибкость архитектуры.

### 4. Повторяемость запросов

*   **TanStack Query:** Используется для эффективного управления запросами, кеширования и дедупликации, что снижает фактические повторные запросы к серверу.
*   **Логика построения запросов:** В файлах `src/api/queries/*.api.ts` наблюдается потенциальная повторяемость в логике построения запросов (например, применение фильтров `.eq()`, `.is()`, `.limit()`, `.order()`). Хотя TanStack Query дедуплицирует одинаковые запросы, сама логика построения запросов может быть абстрагирована для уменьшения дублирования кода и повышения читаемости.
*   **Избыточные запросы клиента:** Как отмечалось ранее, `useGetProjects()` вызывается в каждом `IssueItem`, что приводит к многократным одинаковым запросам к API, несмотря на наличие TanStack Query (который может их дедуплицировать, но это все равно лишняя нагрузка на клиент и сеть).

### 5. Implicit Contracts

*   **UI <> API/Data Access:** Компоненты, использующие данные из `src/api/queries/`, неявно полагаются на структуру возвращаемых данных (например, типы полей, наличие `id`, `project_id`, `module_id`). Это является неявным контрактом, нарушение которого может привести к ошибкам во время выполнения.
*   **API Clients <> `src/api/queries`:** Файлы в `src/api/queries/` напрямую импортируют и используют клиенты (`diogen`, `kaizen`, `tablesDB`). Они неявно предполагают, что эти клиенты предоставляют необходимый API для работы с данными.
*   **`appwrite.config.json` <> `src/api/appwrite.tsx`:** Файл `src/api/appwrite.tsx` зависит от структуры файла `appwrite.config.json` для получения ID баз данных и таблиц (через `appwriteConfig.tables.find(...)`). Это создает неявный контракт, который может быть хрупким при изменениях в файле конфигурации.

### Общие рекомендации:

1.  **Абстракция API-слоя:** Вынести логику формирования запросов к BaaS-провайдерам из `queryFn` в отдельные, более абстрактные сервисы или репозитории. Это позволит изолировать бизнес-логику от деталей инфраструктуры и упростит замену BaaS.
2.  **Централизованное управление конфигурацией API:** Рассмотреть возможность создания более унифицированного способа инициализации и конфигурации BaaS-клиентов.
3.  **Удаление экспериментального кода:** Очистить директорию `src/api/wow/` от временных файлов.
4.  **Оптимизация запросов:** Проверить и оптимизировать случаи, когда избыточные запросы выполняются к API (например, `useGetProjects()` в `IssueItem.tsx`).
